# Авторизация и идентификация

Важные понятия:

Access Token - короткоживущий, не имеет устойчивого хранилища, для веб приложений время жизни от 15 минут до часа. Для повышения безопасности рекомендуется 5 - 15 минут.

Refresh Token - долгоживущий, обычно хранится в cookie (httpOnly cookie)

## Server

### cookie

Установка: `npm i cookie-parser`

еще:
```
    "bcrypt": "^5.1.1",
    "cookie-parser": "^1.4.6",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "nodemon": "^3.1.4",
    "pg": "^8.12.0",
    "pg-hstore": "^2.3.4",
    "sequelize": "^6.37.3",
    "sequelize-cli": "^6.6.2"
```

В app.js **до начала роутов**:

```js
// ....
const cookieParser = require("cookie-parser");
app.use(cookieParser());
// .....
```

Что бы получить cookie:

```js
console.log(req.cookies);
```

### .env

Устанавливаем dotenv (https://www.npmjs.com/package/dotenv) для работы с [переменными среды](https://habr.com/ru/companies/ruvds/articles/351254/)

```
npm i dotenv
```

Создаем в корне проекта файл `.env` с секретным ключом для генерации JWT токенов.

```
ACCESS_TOKEN_SECRET=somesecretkeyhere
REFRESH_TOKEN_SECRET=somesecretkeyhere
```

### Метод генерации токенов

Для генерации токенов нужно установить библиотеку jsonwebtoken `npm i jsonwebtoken`

Для метода генерации токенов можно создать вспомогательную функцию, для обозначения времени жизни access и refresh токенов.

```js
// ./config/jwtConfig.js

const jwtConfig = {
    access: {
      type: 'accessToken',
      expiresIn: `${1000 * 60 * 5}`,
    },
    refresh: {
      type: 'refreshToken',
      expiresIn: `${1000 * 60 * 60 * 12}`,
    },
};
   
module.exports = jwtConfig;
```

Сам метод [генерации](https://my-js.org/docs/cheatsheet/jsonwebtoken/) токенов выгляди следующим образом:

```js
// ./utils/generateTokens.js

require('dotenv').config();
const jwt = require('jsonwebtoken');
const jwtConfig = require('../config/jwtConfig');

function generateTokens(payload) { // payload - это объект с данными пользователя
    return {
      // Создаем токен доступа и токен обновления
      // payload - это объект с данными пользователя
      // process.env.ACCESS_TOKEN_SECRET - это секретный ключ для токена доступа
      // process.env.REFRESH_TOKEN_SECRET - это секретный ключ для токена обновления
      // jwtConfig.access - это объект с настройками для токена доступа  (время жизни токена и тип токена)
      accessToken: jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, {expiresIn: jwtConfig.access.expiresIn}),
      refreshToken: jwt.sign(payload, process.env.REFRESH_TOKEN_SECRET, {expiresIn: jwtConfig.refresh.expiresIn}),
    };
  }

module.exports = generateTokens;
```

Так же стоит сразу создать конфигурацию для cookie:

```js
// ./configs/cookiesConfig.js

const jwtConfig = require("./jwtConfig");

const cookiesConfig = {
  httpOnly: true,
  maxAge: jwtConfig.refresh.expiresIn,
};
module.exports = cookiesConfig;
```

### Middleware для проверки токенов

#### Проверка Access

Обычно используется на роутах, для проверки, авторизирован ли пользователь

```js
// ./middleware/verifyAccessToken.js

require("dotenv").config();
const jwt = require("jsonwebtoken");


function verifyAccessToken(req, res, next) {
  try {
    //Получаем токен из заголовка запроса
    // токен передается в заголовке запроса в поле Authorization вида "Bearer токен"
    const accessToken = req.headers.authorization.split(" ")[1];
    // Проверяем токен на валидность и извлекаем из него данные пользователя
    const { user } = jwt.verify(accessToken, process.env.ACCESS_TOKEN_SECRET);

    // Передаем данные пользователя в следующий middleware или обработчик маршрута
    // через объект res.locals (данные в res.locals доступны только в рамках текущего запроса)
    // После завершения запроса данные удаляются из res.locals
    res.locals.user = user;

    next();
  } catch (error) {
    console.log("Invalid access token");
    res.status(403).send("Invalid access token");
  }
}

module.exports = verifyAccessToken;
```

#### Проверка Refresh

```js
// ./middleware/verifyRefreshToken.js

require("dotenv").config();
const jwt = require("jsonwebtoken");


function verifyRefreshToken(req, res, next) {
  try {
    // Получаем refresh token из куки запроса
    // Токен передается в куки запроса в поле refreshToken
    const { refreshToken } = req.cookies;
    // Проверяем токен на валидность и извлекаем из него данные пользователя
    const { user } = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);
    // Передаем данные пользователя в следующий middleware или обработчик маршрута
    // через объект res.locals (данные в res.locals доступны только в рамках текущего запроса)
    res.locals.user = user;

    next();
  } catch (error) {
    console.log("Invalid refresh token");
    res.clearCookie("refreshToken").sendStatus(401);
  }
}

module.exports = verifyRefreshToken;
```

### Обновляем логику работы роутов авторизации и регистрации

```js
// ./routes/api/auth.routes.js
const authRoute = require("express").Router();
const { User } = require("../../db/models");
const bcrypt = require("bcrypt");
const generateTokens = require("./../../utils/generateTokens");
const jwt = require("jsonwebtoken");
const cookiesConfig = require("../../config/cookiesConfig");

// ...

authRoute.post("/login", async (req, res) => {
  const { email, password } = req.body;
  console.log(req.body);
  if (!email || !password) {
    res.status(400).json({ message: "Не все поля заполнены" });
    return;
  }

  if (email.trim() === "" || password.trim() === "") {
    res.status(400).json({ message: "Поля пустые" });
    return;
  }

  try {
    const targetUser = await User.findOne({
      where: {
        email,
      },
    });
    if (!targetUser)
      return res.status(401).json({ message: "Неверный email или пароль" });

    const IsValidPassword = bcrypt.compare(password, targetUser.password);
    if (!IsValidPassword) {
      res
        .status(401)
        .json({ error, message: "Не правильный пароль или логин" });
      return;
    }
    const user = targetUser.get(); // Получаем объект пользователя из базы данных
    delete user.password; // Удаляем поле password из объекта пользователя

    // Генерируем токены для пользователя

    const { accessToken, refreshToken } = generateTokens({ user });

    res
      .cookie("refreshToken", refreshToken, cookiesConfig) // Отправляем refresh token в куки
      .json({ accessToken, user }); // Отправляем токен доступа и данные пользователя
  } catch (error) {
    res.status(500).json({ error, message: "Нет пользователя" });
  }
});

authRoute.get("/logout", async (req, res) => {
  res.clearCookie("refreshToken").json({ message: "OK" });
});
module.exports = authRoute;
```

### Роут на обновление Access токена

```js
// ./routes/api/tokens.routes.js

const cookiesConfig = require("../../config/cookiesConfig");
const verifyRefreshToken = require("../../middleware/verifyRefreshToken");
const generateTokens = require("../../utils/generateTokens");

const router = require("express").Router();

// Обновление токена доступа и отправка нового токена доступа и данных пользователя
// verifyRefreshToken - проверяет наличие токена обновления и его валидность
router.get("/refresh", verifyRefreshToken, async (req, res) => {
  const { accessToken, refreshToken } = generateTokens({
    user: res.locals.user,
  });
  res
    .cookie("refreshToken", refreshToken, cookiesConfig)
    .json({ accessToken, user: res.locals.user });
});

module.exports = router;
```

## Клиент

Создаем свой экземпляр axios и добавляем перехватчики запросов

```js
// ./services/axiosInstance.js

import axios from "axios";

//  Создаем экземпляр axios

const axiosInstance = axios.create({
  baseURL: "/api",
  withCredentials: true,
  headers: {
    "Content-Type": "application/json",
  },
});

let accessToken = ""; // Токен доступа

function setAccessToken(token) {
  accessToken = token; // Устанавливаем токен доступа
}

/// В каждый запрос добавляет заголовок Authorization
axiosInstance.interceptors.request.use((config) => {
  if (!config.headers.Authorization) {
    config.headers.Authorization = `Bearer ${accessToken}`;
  }
  return config;
});

//  Перехватывает ответы сервера и обрабатывает ошибку 403
axiosInstance.interceptors.response.use(
  (response) => response, // Возвращает ответ, если нет ошибок
  async (error) => {
    // Обрабатывает ошибку
    const prevRequest = error.config; // Получаем предыдущий запрос из ошибки
    if (error.response.status === 403 && !prevRequest.sent) {
      // Если ошибка 403 и запрос не отправлен
      const response = await axios("/api/tokens/refresh"); // Отправляем запрос на обновление токена
      accessToken = response.data.accessToken; // Получаем новый токен доступа
      prevRequest.sent = true; // Устанавливаем флаг отправки запроса в true
      prevRequest.headers.Authorization = `Bearer ${accessToken}`; // Устанавливаем новый токен доступа в заголовок
      return axiosInstance(prevRequest); // Повторно отправляем запрос с новым токеном доступа
    }
    return Promise.reject(error);
  }
);

export { setAccessToken };
export default axiosInstance;
```

## Использование axiosInstance

```js
// ./src/pages/AuthPage.jsx

// Было
// if (result.status === 200) {
//        setUser(result.data.user);
//        navigate("/");
//     }
// Стало

if (result.status === 200) {
  setUser(result.data.user); // см. файл /src/context/userContext.js
  SetAccessToken(result.data.accessToken); // !!!!
  navigate("/"); // Переход на главную страницу используя хук navigate
}
```

## Использование axiosInstance при обновлении страницы

Что бы после обновления пользователь сохранялся

```js
useEffect(() => {
  // или loader route
  axios.get("/api/tokens/refresh").then((data) => {
    console.log(data);
    const { accessToken, user } = data.data;
    setUser(user);
    SetAccessToken(accessToken);
  });
}, []);
```

## Использование axiosInstance и защищенных роутов для получения пользователя

### Клиент

```js
// ./src/components/Todo/TodoList.jsx

// было
// const result = await axios.post("/api/todos", form);
//стало
const result = await axiosInstance.post("/todos", form);
```

### Сервер

```js
// ./src/components/Todo/TodoList.jsx

// было
// todoRoute.post("/", async (req, res) => {})
//стало
const result = await axiosInstance.post("/api/todos", form);
// Было
// const { title, categoryId = "1", userId = "1" } = req.body;
// Стало
const userId = res.locals.user.id;
const { title, categoryId } = req.body;

const todo = await Todo.create({ ...req.body, userId });
```

![alt text](image.png)
